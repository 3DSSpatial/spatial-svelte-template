// Generate unique IDs for use as pseudo-private/protected names.
// Similar in concept to
// <http://wiki.ecmascript.org/doku.php?id=strawman:names>.
//
// The goals of this function are twofold:
//
// * Provide a way to generate a string guaranteed to be unique when compared
//   to other strings generated by this function.
// * Make the string complex enough that it is highly unlikely to be
//   accidentally duplicated by hand (this is key if you're using `ID`
//   as a private/protected name on an object).
//
// Use:
//
//     var privateName = ID();
//     var o = { 'public': 'foo' };
//     o[privateName] = 'bar';
var ID = function () {
  // Math.random should be unique because of its seeding algorithm.
  // Convert it to base 36 (numbers + letters), and grab the first 9 characters
  // after the decimal.
  return '_' + Math.random().toString(36).substr(2, 9)
}

class ChannelMessenger {
  constructor(viewer) {
    this.listeners = {}
    this.resolves = {}

    const channel = new MessageChannel()
    this.port1 = channel.port1

    // Wait for the viewer to load

    viewer.addEventListener('load', () => {
      // Listen for messages on port1
      this.port1.onmessage = onMessage

      // Note: without this timeout, the Svelte app
      // has not initialized its ChannelMessenger by the time
      // we send the init message. We may be able to remove this after
      // Mauro's updates.
      setTimeout(() => {
        // Transfer port2 to the viewer
        viewer.contentWindow.postMessage('init', '*', [channel.port2])
      }, 50)
    })

    // Handle messages received on port1
    const onMessage = (e) => {
      if (e.data == 'ready') {
        this.emit('ready')
      } else {
        if (Array.isArray(e.data) && e.data.length == 2) {
          const key = e.data[0]
          const data = e.data[1]

          // If the data is part of a response to a command, then resolve
          // the original promise
          if (this.resolves[key]) {
            const resolve = this.resolves[key]
            delete this.resolves[key]
            resolve(data)
          } else {
            this.emit(key, data)
          }
        }
      }
    }
  }

  do(msg, payload = {}, timeout = 5000) {
    return new Promise((resolve, reject) => {
      const id = ID()
      payload._id = id
      this.resolves[id] = resolve
      this.port1.postMessage([msg, payload])
    })
  }

  /**
   * Adds a listener function for a given event name.
   *
   * @param {string} eventName - The name of the event.
   * @param {function} listener - The listener function(callback).
   * @return {number} - Id to reference the listener.
   */
  on(eventName, listener) {
    if (!listener) {
      throw new Error('Missing callback function (listener).')
    }

    if (!this.listeners[eventName]) {
      this.listeners[eventName] = []
    }

    const listeners = this.listeners[eventName]

    if (listeners.includes(listener)) {
      throw new Error(
        `Listener "${listener.name}" already connected to event "${eventName}".`
      )
    }

    // TODO: Deprecate alongside #addListener.
    const id = listeners.length
    listeners[id] = listener

    return id
  }

  /**
   * Similar to the `on` method with the difference that when the event is triggered,
   * it is automatically unregistered meaning that the event listener will be triggered at most one time.
   *
   * Useful for events that we expect to trigger one time, such as when assets load.
   * ```javascript
   * const asset = new Asset();
   * asset.once('loaded', () => {
   *   console.log("Yay! the asset is loaded")
   * })
   * ```
   *
   * @param {string} eventName - The eventName value
   * @param {function} listener - The listener value
   */
  once(eventName, listener) {
    const cb = (event) => {
      listener(event)
      this.off(eventName, cb)
    }

    this.on(eventName, cb)
  }

  /**
   * Removes a listener function from the specified event, using either the function or the index id. Depends on what is passed in.
   *
   * @param {string} eventName - The name of the event.
   * @param {function|number} listener - The listener function or the id number.
   */
  off(eventName, listener) {
    if (!listener) {
      throw new Error('Missing callback function (listener).')
    }

    if (typeof listener == 'number') {
      console.warn(
        'Deprecated. Un-register using the original listener instead.'
      )
      this.removeListenerById(eventName, listener)
      return
    }

    const listeners = this.listeners[eventName] || []

    const ids = []

    listeners.forEach((e, i) => {
      if (e === listener) {
        ids.push(i)
      }
    })

    if (ids.length == 0) {
      throw new Error(
        `Listener "${listener.name}" is not connected to "${eventName}" event`
      )
    } else {
      for (const id of ids) {
        listeners[id] = undefined
      }
    }
  }

  /**
   * Triggers all listener functions in an event.
   *
   * @param {string} eventName - The name of the event.
   * @param {object|string|any} event - The data you want to pass down to all listener functions as parameter.
   */
  emit(eventName, event) {
    const listeners = this.listeners[eventName] || []

    listeners.forEach((fn) => {
      // Skip disconnected listeners.
      if (fn) {
        fn(event)
      }
    })
  }
}

export { ChannelMessenger }
